% author: Sabrina Rosmann, Mathias Nigsch, Karin Trommelschl√§ger, Jasmin Pogatschneg% implementation for (mu/muI,lambda)-sigmaSA-ES% input% y - initial point [Nx1]% sigma - mutation strength% sigma stop - the algorithm is stopped if the initial mutation strenght is smaller than sigma stop% % lamba - the number of offsprings per generation% fun - function to minimize% funopt - additional parameters for function call (optional argument)  % output % parentsRecomb - final point% fp - function value of final point% g - generation counter% stats - some statistical valuesfunction[parentsRecomb, fp, g, stats] = MuMuILambdaES(y, sigma, sigmaStop, gLimit, mu, lambda, fun, tau=(1/sqrt(2*length(y))), funopt = [])  % initialize parameters  g = 0; % generation counter  offsprings = cell(1,lambda);  parents = cell(1,mu);  for i=1:mu     parents(i) = y;  end  for i=1:mu    parentsSigma(i) = sigma;  end  parentsRecomb = y;  sigmaRecomb = sigma;  randn('state',7);  stats.funEvals = 0;    do    for i=1:lambda      sigmaNew = exp(tau*randn(1))*sigmaRecomb;      ynew = parentsRecomb + sigmaNew*randn(length(y),1);      fnew = feval(fun,ynew,funopt);      stats.funEvals = stats.funEvals + 1;      stats.funValPerFunEval(stats.funEvals) = fnew;      offspringsSigma(i) = sigmaNew;      offsprings(i) = ynew;      offspringsFitness(i) = fnew;    end    for i=1:mu       % evaluate best offspring      bestFitness = min(offspringsFitness);      indexBestOffspring = find(offspringsFitness == bestFitness);      % set best offspring as parent      parentsFitness(i) = offspringsFitness(indexBestOffspring);      parentsSigma(i) = offspringsSigma(indexBestOffspring);      parents(i) = offsprings(indexBestOffspring);      % set fitness of current best offspring to infinity      offspringsFitness(indexBestOffspring) = Inf;    end    % calculate recombinations parents and their sigmas    sigmaRecomb = mean(parentsSigma);    parentsSum = 0;    for i=1:mu      parentsSum = parentsSum + cell2mat(parents(i));    end    parentsRecomb = parentsSum/mu;        fp = feval(fun,parentsRecomb,funopt);    stats.funEvals = stats.funEvals + 1;    stats.funValPerFunEval(stats.funEvals) = fp;    g = g + 1;    stats.funval(g) = fp;    stats.sigma(g) = sigmaRecomb;     % normalise mutation strength    sigmaNorm = sigmaRecomb / sqrt(fp) * length(y); % Restzielabstand bei kugel: sqrt(fnew)     stats.sigmaNorm(g) = sigmaNorm;  until (sigmaRecomb < sigmaStop|| g > gLimit)end